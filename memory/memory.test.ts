
import { describe, it, expect, beforeAll } from 'vitest';
import { VectorStore } from './vector_store/index';
import { MemoryRouter, MemoryType } from './router';

// Increase timeout for LLM operations
const TIMEOUT = 30000;

describe('Memory Architecture', () => {
  
  describe('Router', () => {
    // We use keyword-based routing for deterministic tests
    const router = new MemoryRouter(false); 

    it('should route "How was my run today?" to DYNAMIC_MEMORY', async () => {
      const result = await router.route("How was my run today?");
      expect(result).toBe(MemoryType.DYNAMIC);
    });

    it('should route "What is your experience with React?" to STATIC_MEMORY', async () => {
      const result = await router.route("What is your experience with React?");
      expect(result).toBe(MemoryType.STATIC);
    });

    it('should route "Hi, how are you?" to CONVERSATIONAL_MEMORY', async () => {
      const result = await router.route("Hi, how are you?");
      expect(result).toBe(MemoryType.CONVERSATIONAL);
    });
  });

  describe('VectorStore', () => {
    let vectorStore: VectorStore;

    beforeAll(async () => {
      // Ensure we load the correct file that was generated by ingest.ts
      const path = await import('path');
      const storePath = path.resolve(process.cwd(), 'data/embedded_vectors.json');
      console.log('Test connecting to store at:', storePath);
      vectorStore = new VectorStore('embedded_vectors.json'); 
      await vectorStore.load();
    });

    it('should retrieve relevant documents for "Next.js"', async () => {
      const results = await vectorStore.search("Next.js", 2);
      expect(results.length).toBeGreaterThan(0);
      
      const content = results[0].doc.content;
      // Expecting skills or profile related to tech
      expect(content).toEqual(expect.stringMatching(/Next\.js|React|Tech/i));
    }, TIMEOUT);

    it('should retrieve relevant documents for "Running goals"', async () => {
        const results = await vectorStore.search("Running goals", 2);
        expect(results.length).toBeGreaterThan(0);
        
        const content = results[0].doc.content;
        expect(content).toEqual(expect.stringMatching(/Running|Interests|Goals/i));
    }, TIMEOUT);
    
    it('should return scores for search results', async () => {
        const results = await vectorStore.search("Next.js", 1);
        expect(results[0].score).toBeDefined();
        // Cosine similarity is usually between -1 and 1
        expect(results[0].score).toBeGreaterThan(-1);
        expect(results[0].score).toBeLessThanOrEqual(1);
    }, TIMEOUT);
  });
});
